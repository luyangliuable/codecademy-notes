# Control Flow
<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
**Table of Contents**

- [Control Flow](#control-flow)
    - [Control Flow Issues](#control-flow-issues)
    - [Data Flow Issues](#data-flow-issues)
    - [Control Flow Integrity](#control-flow-integrity)
    - [Graphs](#graphs)
        - [Call Graph](#call-graph)
        - [Control Flow Graph](#control-flow-graph)
    - [Control Flow Integrity [#CFI]() [#static-analysis]() [#runtime]() [#CFI-label]()](#control-flow-integrity-cfi-static-analysis-runtime-cfi-label)
        - [CFI: Compliance with CFG [#direct-calls]() [#indirect-calls]() [#compliance]()](#cfi-compliance-with-cfg-direct-calls-indirect-calls-compliance)
        - [In-Line Monitor](#in-line-monitor)
        - [Why CFI is Effective? [#CFI-label]()](#why-cfi-is-effective-cfi-label)
        - [Shortcomings of CFI  [#self-modifying-code]() [#heartbleed]()](#shortcomings-of-cfi--self-modifying-code-heartbleed)

<!-- markdown-toc end -->

## Control Flow Issues 
Improper control of flow of execution within a software system.

* Often **control flow hijacking attack**.

Examples:
* A file is configured properly before use
* Infinite loops
* Improper access controls
* Race conditions
* Improper error handling 
* Buffer overflows

## Data Flow Issues
Improper control of the flow data within a software system
* Long user input data copied into fixed size buffer.
* XSS 
* SQL
* CSRF

## Control Flow Integrity
> "Observe the program's behaviour - is it doing what we expect it to do?"
  * If not, might be compromised
* Challenges
  * Defined "**expected behavior**"
    * Use control flow graph (CFG)
  * Define **deviations from expectation** efficiently
    * In-line reference monitor (IRM)
  * Avoid compromise of the control flow integrity detector
    * Sufficient randomness, immutability

## Graphs
* Example

```csharp
public void sort(int a[], int b[], int len) {
    sort(b, len, lt)
    sort(b, len, gt)
}

public bool lt(int x, int y) {
    return x<y;
}


public bool lt(int x, int y) {
    return x>y;
}
```

### Call Graph
Which functions call other functions

```
 -------                         ---> ----
|sort2  |            --------   /    | lt |
|       |  -------> |sort    | /      ----
|       |            -------- 
|       |           |        | \
 -------             --------   \
                                 \      ----
                                  ---> | gt |
                                        ----
```

### Control Flow Graph
Arrows with calls and returns.

```
 -------                         --->  ----
|sort2  |  ------->  --------   /     | lt |
|       |  <------- |sort    | /   --> ----
|       |  ------->  --------  <--/
|       |  <------- |        | \
 -------             --------   \
                              ^  \       ----
                               \  \---> | gt |
                                -------- ----
```
## Control Flow Integrity [#CFI]() [#static-analysis]() [#runtime]() [#CFI-label]()

### CFI: Compliance with CFG [#direct-calls]() [#indirect-calls]() [#compliance]()
* Direct calls:
  * The target (function) of the call is known and fixed at the time the edge is created.

* Indirect calls:
  * The call is not known until runtime.
  * Value stored in a register or calling a function pointer.
  * Computed dynamically.

* Compute the call/return CFG in advance
  * During compilation, or from the binary

* Monitor the control flow of the program and ensure that it only follows paths allowed by the CFG

* Observations: **Direct calls need not be monitored**
  * Assuming the code is immutable, the target address cannot be changed

* Therefore: **monitor only indirect calls**
  * jmp, call, ret with non-constant targets
  

### In-Line Monitor
* Implement the monitor in-line, as a **program transformation**.
* Insert a **label just before the target address** of an indirect transfer.
* Insert a **code to check the label of the target** at each indirect transfer.
  * Abort if the label does not match
* The **labels are determined by the CFG**

* Labeling-based Control Flow Integrity (CFI) is a security mechanism to defend against control-flow hijacking attacks

* Labeling-based CFI works by labeling each basic block in control flow graph and enforcing a policy on the flow of control

* The labels can be generated by static analysis of binary or by instrumenting code at runtime

### Why CFI is Effective? [#CFI-label]()
* Code is immutable
    * So code labels cannot be modified for undesirable control flow.
* Non-executable data (stack and buffer)
    * So code with legal label cannot be injected to run.

* Defeats control-flow modifying attacks like race condition, buffer overflow.
* Prevents data leaks and corruption TODO is this true?

### Shortcomings of CFI  [#self-modifying-code]() [#heartbleed]()

TODO Is this true?

* Heartbleed will not be prevented
* Presence of self-modifying code cause control modification to be allowed by graph.
